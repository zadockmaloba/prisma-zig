const std = @import("std");
const pq = @import("libpq_zig");
const types = @import("schema/types.zig");

pub fn generateMigrationSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Migration generated by Prisma Zig\n");
    try writer.writeAll("-- This is a basic migration that creates tables for all models\n\n");

    // Generate CREATE TABLE statements for each model
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        const db_provider = if (schema.datasource) |ds| ds.provider else "postgresql";

        try writer.print("-- DropTable if exists\nDROP TABLE IF EXISTS \"{s}\" CASCADE;\n\n", .{table_name.value});
        try writer.print("-- CreateTable\nCREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            // Skip relationship fields (they don't map to columns directly)
            if (field.type.isRelation()) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else {
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    var sql_type_buf: [64]u8 = undefined;
                    const sql_type_raw = field.getSqlType(db_provider);
                    const sql_type = blk: {
                        if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                            var i: usize = 0;
                            for (sql_type_raw) |c| {
                                sql_type_buf[i] = std.ascii.toUpper(c);
                                i += 1;
                                if (i >= sql_type_buf.len) break;
                            }
                            break :blk sql_type_buf[0..sql_type_raw.len];
                        }
                        break :blk sql_type_raw;
                    };
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                var sql_type_buf: [64]u8 = undefined;
                const sql_type_raw = field.getSqlType(db_provider);
                const sql_type = blk: {
                    if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                        var i: usize = 0;
                        for (sql_type_raw) |c| {
                            sql_type_buf[i] = std.ascii.toUpper(c);
                            i += 1;
                            if (i >= sql_type_buf.len) break;
                        }
                        break :blk sql_type_buf[0..sql_type_raw.len];
                    }
                    break :blk sql_type_raw;
                };
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }
            }

            // Add unique constraint for non-primary-key unique fields
            if (field.isUnique() and !field.isPrimaryKey()) {
                try writer.writeAll(" UNIQUE");
            }

            // Add default values (skip autoincrement as it's handled above)
            if (!field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (field.type == .string) {
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate indexes for unique fields and foreign keys
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        for (model.fields.items) |*field| {
            if (field.isUnique() and !field.isPrimaryKey()) {
                const column_name = field.getColumnName();
                try writer.print("-- CreateIndex\nCREATE UNIQUE INDEX \"{s}_{s}_key\" ON \"{s}\"({s});\n\n", .{ table_name.value, column_name, table_name.value, column_name });
            }
        }
    }

    return sql.toOwnedSlice(allocator);
}

pub fn generatePushSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    // This generates SQL to push the schema to the database
    // Similar to generateMigrationSql but without the migration metadata

    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Schema push generated by Prisma Zig\n");
    try writer.writeAll("-- Applying current schema to database\n\n");

    // For a real implementation, we would:
    // 1. Compare current database schema with Prisma schema
    // 2. Generate ALTER TABLE, CREATE TABLE, DROP TABLE statements as needed
    // 3. Handle index creation/deletion
    // 4. Handle foreign key constraints

    // Drop and recreate tables to handle schema changes
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        try writer.print("DROP TABLE IF EXISTS \"{s}\" CASCADE;\n", .{table_name.value});
    }

    try writer.writeAll("\n");

    // Now create all tables
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        const db_provider = if (schema.datasource) |ds| ds.provider else "postgresql";

        try writer.print("CREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            if (field.type.isRelation()) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else {
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    var sql_type_buf: [64]u8 = undefined;
                    const sql_type_raw = field.getSqlType(db_provider);
                    const sql_type = blk: {
                        if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                            var i: usize = 0;
                            for (sql_type_raw) |c| {
                                sql_type_buf[i] = std.ascii.toUpper(c);
                                i += 1;
                                if (i >= sql_type_buf.len) break;
                            }
                            break :blk sql_type_buf[0..sql_type_raw.len];
                        }
                        break :blk sql_type_raw;
                    };
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                var sql_type_buf: [64]u8 = undefined;
                const sql_type_raw = field.getSqlType(db_provider);
                const sql_type = blk: {
                    if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                        var i: usize = 0;
                        for (sql_type_raw) |c| {
                            sql_type_buf[i] = std.ascii.toUpper(c);
                            i += 1;
                            if (i >= sql_type_buf.len) break;
                        }
                        break :blk sql_type_buf[0..sql_type_raw.len];
                    }
                    break :blk sql_type_raw;
                };
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }

                if (field.isUnique()) {
                    try writer.writeAll(" UNIQUE");
                }

                // Add default values for non-primary-key fields
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (field.type == .string) {
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    return sql.toOwnedSlice(allocator);
}
