const std = @import("std");
const pq = @import("libpq_zig");
const types = @import("schema/types.zig");

// Helper function to map Prisma referential actions to SQL
fn mapReferentialAction(action: []const u8) []const u8 {
    if (std.mem.eql(u8, action, "Cascade")) return "CASCADE";
    if (std.mem.eql(u8, action, "NoAction")) return "NO ACTION";
    if (std.mem.eql(u8, action, "SetNull")) return "SET NULL";
    if (std.mem.eql(u8, action, "SetDefault")) return "SET DEFAULT";
    if (std.mem.eql(u8, action, "Restrict")) return "RESTRICT";
    return "NO ACTION"; // Default fallback
}

// Helper function to check if a field references an enum type
fn isEnumField(field: *const types.Field, schema: *const types.Schema) bool {
    if (field.type == .model_ref) {
        const type_name = field.type.model_ref;
        if (schema.getEnum(type_name)) |_| {
            return true;
        }
    }
    return false;
}

// Helper function to get SQL type for a field, considering enums
fn getFieldSqlType(field: *const types.Field, schema: *const types.Schema, db_provider: []const u8) []const u8 {
    // First check if this is an enum type
    if (field.type == .model_ref) {
        const type_name = field.type.model_ref;
        // Check if this type is an enum
        if (schema.getEnum(type_name)) |_| {
            // It's an enum, return the enum type name (caller should quote it)
            return type_name;
        }
    }

    // Otherwise use the standard SQL type
    return field.getSqlType(db_provider);
}

// Helper function to check if a field is a true relation (not an enum)
fn isFieldRelation(field: *const types.Field, schema: *const types.Schema) bool {
    if (!field.type.isRelation()) return false;

    // If it's a model_ref, check if it's actually an enum
    if (field.type == .model_ref) {
        const type_name = field.type.model_ref;
        if (schema.getEnum(type_name)) |_| {
            // It's an enum, not a relation
            return false;
        }
    }

    return true;
}

pub fn generateMigrationSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Migration generated by Prisma Zig\n");
    try writer.writeAll("-- This is a basic migration that creates tables for all models\n\n");

    // Generate CREATE TYPE statements for enums
    for (schema.enums.items) |*prisma_enum| {
        try writer.print("-- Drop enum if exists\nDROP TYPE IF EXISTS \"{s}\" CASCADE;\n\n", .{prisma_enum.name});
        try writer.print("-- CreateEnum\nCREATE TYPE \"{s}\" AS ENUM (\n", .{prisma_enum.name});

        for (prisma_enum.values.items, 0..) |value, i| {
            if (i > 0) try writer.writeAll(",\n");
            try writer.print("    '{s}'", .{value});
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate CREATE TABLE statements for each model
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        const db_provider = if (schema.datasource) |ds| ds.provider else "postgresql";

        try writer.print("-- DropTable if exists\nDROP TABLE IF EXISTS \"{s}\" CASCADE;\n\n", .{table_name.value});
        try writer.print("-- CreateTable\nCREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            // Skip relationship fields (they don't map to columns directly)
            if (isFieldRelation(field, schema)) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else if (std.mem.eql(u8, default_val, "uuid()")) {
                        // Handle UUID default
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                        const sql_type = blk: {
                            if (isEnumField(field, schema)) {
                                const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                                break :blk quoted;
                            }
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY DEFAULT gen_random_uuid()", .{ column_name, sql_type });
                    } else {
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                        const sql_type = blk: {
                            if (isEnumField(field, schema)) {
                                const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                                break :blk quoted;
                            }
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    var sql_type_buf: [64]u8 = undefined;
                    const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                    const sql_type = blk: {
                        if (isEnumField(field, schema)) {
                            const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                            break :blk quoted;
                        }
                        if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                            var i: usize = 0;
                            for (sql_type_raw) |c| {
                                sql_type_buf[i] = std.ascii.toUpper(c);
                                i += 1;
                                if (i >= sql_type_buf.len) break;
                            }
                            break :blk sql_type_buf[0..sql_type_raw.len];
                        }
                        break :blk sql_type_raw;
                    };
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                var sql_type_buf: [64]u8 = undefined;
                const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                const sql_type = blk: {
                    if (isEnumField(field, schema)) {
                        const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                        break :blk quoted;
                    }
                    // Check if this is an enum type and quote it
                    if (isEnumField(field, schema)) {
                        const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                        break :blk quoted;
                    }
                    if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                        var i: usize = 0;
                        for (sql_type_raw) |c| {
                            sql_type_buf[i] = std.ascii.toUpper(c);
                            i += 1;
                            if (i >= sql_type_buf.len) break;
                        }
                        break :blk sql_type_buf[0..sql_type_raw.len];
                    }
                    break :blk sql_type_raw;
                };
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }
            }

            // Add unique constraint for non-primary-key unique fields
            if (field.isUnique() and !field.isPrimaryKey()) {
                try writer.writeAll(" UNIQUE");
            }

            // Add default values (skip autoincrement as it's handled above)
            if (!field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()") and !std.mem.eql(u8, default_val, "uuid()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (std.mem.startsWith(u8, default_val, "dbgenerated(")) {
                            // Extract the SQL from dbgenerated("...")
                            const start = std.mem.indexOf(u8, default_val, "\"") orelse 0;
                            const end = std.mem.lastIndexOf(u8, default_val, "\"") orelse default_val.len;
                            const sql_expr = if (start < end) default_val[start + 1 .. end] else "";
                            try writer.print(" DEFAULT {s}", .{sql_expr});
                        } else if (field.type == .string or isEnumField(field, schema)) {
                            // Enum values need to be quoted as strings in SQL
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate indexes for unique fields and foreign keys
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        for (model.fields.items) |*field| {
            if (field.isUnique() and !field.isPrimaryKey()) {
                const column_name = field.getColumnName();
                try writer.print("-- CreateIndex\nCREATE INDEX IF NOT EXISTS \"{s}_{s}_key\" ON \"{s}\"({s});\n\n", .{ table_name.value, column_name, table_name.value, column_name });
            }
        }

        // Handle model-level @@index(...) attributes
        for (model.indexes.items) |idx| {
            const raw = idx.value;
            // Extract fields between [ and ]
            if (std.mem.indexOf(u8, raw, "[")) |bs| {
                var be = bs + 1;
                while (be < raw.len and raw[be] != ']') : (be += 1) {}
                if (be >= raw.len) be = raw.len - 1;
                const fields_slice = raw[bs + 1 .. be];

                // Split fields by comma
                var parts: std.ArrayList([]const u8) = .empty;
                defer parts.deinit(allocator);
                var start: usize = 0;
                var i: usize = 0;
                while (i <= fields_slice.len) {
                    if (i == fields_slice.len or fields_slice[i] == ',') {
                        // trim start..i
                        var s = start;
                        var e = i;
                        while (s < e and std.ascii.isWhitespace(fields_slice[s])) s += 1;
                        while (e > s and std.ascii.isWhitespace(fields_slice[e - 1])) e -= 1;
                        if (e > s) {
                            try parts.append(allocator, fields_slice[s..e]);
                        }
                        start = i + 1;
                    }
                    i += 1;
                }

                // Build quoted column list and find first field for fallback name
                var col_list: std.ArrayList(u8) = .empty;
                defer col_list.deinit(allocator);
                var first_col_name: []const u8 = "";
                var first = true;
                for (parts.items) |p| {
                    // Parse field name and optional sort order: fieldName(sort: Desc)
                    var field_name = p;
                    var sort_order: ?[]const u8 = null;

                    if (std.mem.indexOf(u8, p, "(")) |paren_pos| {
                        field_name = p[0..paren_pos];
                        // Check for sort order
                        if (std.mem.indexOf(u8, p, "Desc")) |_| {
                            sort_order = "DESC";
                        } else if (std.mem.indexOf(u8, p, "Asc")) |_| {
                            sort_order = "ASC";
                        }
                    }

                    var column_name: []const u8 = field_name;
                    if (model.getField(field_name)) |f| {
                        column_name = f.getColumnName();
                    }
                    if (!first) try col_list.appendSlice(allocator, ", ");
                    try col_list.appendSlice(allocator, "\"");
                    try col_list.appendSlice(allocator, column_name);
                    try col_list.appendSlice(allocator, "\"");
                    if (sort_order) |order| {
                        try col_list.appendSlice(allocator, " ");
                        try col_list.appendSlice(allocator, order);
                    }
                    if (first) {
                        first_col_name = column_name;
                        first = false;
                    }
                }

                // Determine index name if provided: look for name: "..."
                var index_name: ?[]const u8 = null;
                if (std.mem.indexOf(u8, raw, "name")) |npos| {
                    var q1: usize = npos;
                    while (q1 < raw.len and raw[q1] != '"') : (q1 += 1) {}
                    const q2 = std.mem.lastIndexOf(u8, raw, "\"") orelse raw.len;
                    if (q1 < q2) {
                        index_name = raw[q1 + 1 .. q2];
                    }
                }

                const idx_name = if (index_name) |inm| inm else try std.fmt.allocPrint(allocator, "{s}_{s}_idx", .{ table_name.value, first_col_name });
                defer if (index_name == null) allocator.free(idx_name);

                try writer.print("-- Create model index\nCREATE INDEX IF NOT EXISTS \"{s}\" ON \"{s}\"({s});\n\n", .{ idx_name, table_name.value, col_list.items });
            }
        }
    }

    // Generate foreign key constraints
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        for (model.fields.items) |field| {
            // Check if this field has a @relation attribute with fields and references
            // Check if this field has a @relation attribute with fields and references
            for (field.attributes.items) |attr| {
                if (attr == .relation) {
                    const rel = attr.relation;

                    // Only generate FK if this side defines the fields (owning side)
                    if (rel.fields != null and rel.references != null and rel.fields.?.len > 0 and rel.references.?.len > 0) {
                        const fields = rel.fields.?;
                        const references = rel.references.?;

                        // Determine the referenced table name from the field type
                        const ref_model_name = field.type.getModelName() orelse continue;

                        // Get the actual table name from the referenced model (respects @@map)
                        const ref_model_lookup = schema.getModel(ref_model_name) orelse continue;
                        const ref_table = try ref_model_lookup.getTableName(allocator);
                        defer if (ref_table.heap_allocated) allocator.free(ref_table.value);

                        // Build field list and reference list using mapped column names
                        var field_list: std.ArrayList(u8) = .empty;
                        defer field_list.deinit(allocator);
                        var ref_list: std.ArrayList(u8) = .empty;
                        defer ref_list.deinit(allocator);

                        // Map field names to actual column names (handle @map)
                        for (fields, 0..) |fld, i| {
                            if (i > 0) try field_list.appendSlice(allocator, ", ");
                            try field_list.append(allocator, '"');

                            // Look up the field in the current model to get its column name
                            if (model.getField(fld.value)) |field_def| {
                                try field_list.appendSlice(allocator, field_def.getColumnName());
                            } else {
                                // Fallback to field name if not found
                                try field_list.appendSlice(allocator, fld.value);
                            }
                            try field_list.append(allocator, '"');
                        }

                        // Get the referenced model to map reference field names to column names
                        const ref_model = schema.getModel(ref_model_name);
                        for (references, 0..) |ref, i| {
                            if (i > 0) try ref_list.appendSlice(allocator, ", ");
                            try ref_list.append(allocator, '"');

                            // Look up the field in the referenced model to get its column name
                            if (ref_model) |rm| {
                                if (rm.getField(ref.value)) |ref_field_def| {
                                    try ref_list.appendSlice(allocator, ref_field_def.getColumnName());
                                } else {
                                    try ref_list.appendSlice(allocator, ref.value);
                                }
                            } else {
                                // Fallback to field name if model not found
                                try ref_list.appendSlice(allocator, ref.value);
                            }
                            try ref_list.append(allocator, '"');
                        }

                        // Map Prisma actions to SQL
                        const on_delete = if (rel.onDelete) |action|
                            mapReferentialAction(action)
                        else
                            "NO ACTION";
                        const on_update = if (rel.onUpdate) |action|
                            mapReferentialAction(action)
                        else
                            "NO ACTION";

                        // Generate constraint name
                        const constraint_name = try std.fmt.allocPrint(allocator, "{s}_{s}_fkey", .{ table_name.value, fields[0].value });
                        defer allocator.free(constraint_name);

                        try writer.print("-- Create foreign key constraint\nALTER TABLE \"{s}\" ADD CONSTRAINT \"{s}\" FOREIGN KEY ({s}) REFERENCES \"{s}\"({s}) ON DELETE {s} ON UPDATE {s};\n\n", .{ table_name.value, constraint_name, field_list.items, ref_table.value, ref_list.items, on_delete, on_update });
                    }
                }
            }
        }
    }

    return sql.toOwnedSlice(allocator);
}

pub fn generatePushSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    // This generates SQL to push the schema to the database
    // Similar to generateMigrationSql but without the migration metadata

    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Schema push generated by Prisma Zig\n");
    try writer.writeAll("-- Applying current schema to database\n\n");

    // Generate CREATE TYPE statements for enums
    for (schema.enums.items) |*prisma_enum| {
        try writer.print("DROP TYPE IF EXISTS \"{s}\" CASCADE;\n", .{prisma_enum.name});
    }
    try writer.writeAll("\n");

    for (schema.enums.items) |*prisma_enum| {
        try writer.print("CREATE TYPE \"{s}\" AS ENUM (\n", .{prisma_enum.name});

        for (prisma_enum.values.items, 0..) |value, i| {
            if (i > 0) try writer.writeAll(",\n");
            try writer.print("    '{s}'", .{value});
        }

        try writer.writeAll("\n);\n\n");
    }

    // For a real implementation, we would:
    // 1. Compare current database schema with Prisma schema
    // 2. Generate ALTER TABLE, CREATE TABLE, DROP TABLE statements as needed
    // 3. Handle index creation/deletion
    // 4. Handle foreign key constraints

    // Drop and recreate tables to handle schema changes
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        try writer.print("DROP TABLE IF EXISTS \"{s}\" CASCADE;\n", .{table_name.value});
    }

    try writer.writeAll("\n");

    // Now create all tables
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        const db_provider = if (schema.datasource) |ds| ds.provider else "postgresql";

        try writer.print("CREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            if (isFieldRelation(field, schema)) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else if (std.mem.eql(u8, default_val, "uuid()")) {
                        // Handle UUID default
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                        const sql_type = blk: {
                            if (isEnumField(field, schema)) {
                                const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                                break :blk quoted;
                            }
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY DEFAULT gen_random_uuid()", .{ column_name, sql_type });
                    } else if (std.mem.startsWith(u8, default_val, "dbgenerated(")) {
                        // Handle dbgenerated() - extract SQL expression from dbgenerated("...")
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                        const sql_type = blk: {
                            if (isEnumField(field, schema)) {
                                const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                                break :blk quoted;
                            }
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        // Extract the SQL from dbgenerated("...")
                        const start = std.mem.indexOf(u8, default_val, "\"") orelse 0;
                        const end = std.mem.lastIndexOf(u8, default_val, "\"") orelse default_val.len;
                        const sql_expr = if (start < end) default_val[start + 1 .. end] else "";
                        try writer.print("    \"{s}\" {s} PRIMARY KEY DEFAULT {s}", .{ column_name, sql_type, sql_expr });
                    } else {
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                        const sql_type = blk: {
                            if (isEnumField(field, schema)) {
                                const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                                break :blk quoted;
                            }
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    var sql_type_buf: [64]u8 = undefined;
                    const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                    const sql_type = blk: {
                        if (isEnumField(field, schema)) {
                            const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                            break :blk quoted;
                        }
                        if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                            var i: usize = 0;
                            for (sql_type_raw) |c| {
                                sql_type_buf[i] = std.ascii.toUpper(c);
                                i += 1;
                                if (i >= sql_type_buf.len) break;
                            }
                            break :blk sql_type_buf[0..sql_type_raw.len];
                        }
                        break :blk sql_type_raw;
                    };
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                var sql_type_buf: [64]u8 = undefined;
                const sql_type_raw = getFieldSqlType(field, schema, db_provider);
                const sql_type = blk: {
                    if (isEnumField(field, schema)) {
                        const quoted = std.fmt.bufPrint(&sql_type_buf, "\"{s}\"", .{sql_type_raw}) catch sql_type_raw;
                        break :blk quoted;
                    }
                    if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                        var i: usize = 0;
                        for (sql_type_raw) |c| {
                            sql_type_buf[i] = std.ascii.toUpper(c);
                            i += 1;
                            if (i >= sql_type_buf.len) break;
                        }
                        break :blk sql_type_buf[0..sql_type_raw.len];
                    }
                    break :blk sql_type_raw;
                };
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }

                if (field.isUnique()) {
                    try writer.writeAll(" UNIQUE");
                }

                // Add default values for non-primary-key fields
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()") and !std.mem.eql(u8, default_val, "uuid()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (std.mem.startsWith(u8, default_val, "dbgenerated(")) {
                            // Extract the SQL from dbgenerated("...")
                            const start = std.mem.indexOf(u8, default_val, "\"") orelse 0;
                            const end = std.mem.lastIndexOf(u8, default_val, "\"") orelse default_val.len;
                            const sql_expr = if (start < end) default_val[start + 1 .. end] else "";
                            try writer.print(" DEFAULT {s}", .{sql_expr});
                        } else if (field.type == .string or isEnumField(field, schema)) {
                            // Enum values need to be quoted as strings in SQL
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate indexes for unique fields and model-level @@index
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        // Handle model-level @@index(...) attributes
        for (model.indexes.items) |idx| {
            const raw = idx.value;
            // Extract fields between [ and ]
            if (std.mem.indexOf(u8, raw, "[")) |bs| {
                var be = bs + 1;
                while (be < raw.len and raw[be] != ']') : (be += 1) {}
                if (be >= raw.len) be = raw.len - 1;
                const fields_slice = raw[bs + 1 .. be];

                // Split fields by comma
                var parts: std.ArrayList([]const u8) = .empty;
                defer parts.deinit(allocator);
                var start: usize = 0;
                var i: usize = 0;
                while (i <= fields_slice.len) {
                    if (i == fields_slice.len or fields_slice[i] == ',') {
                        // trim start..i
                        var s = start;
                        var e = i;
                        while (s < e and std.ascii.isWhitespace(fields_slice[s])) s += 1;
                        while (e > s and std.ascii.isWhitespace(fields_slice[e - 1])) e -= 1;
                        if (e > s) {
                            try parts.append(allocator, fields_slice[s..e]);
                        }
                        start = i + 1;
                    }
                    i += 1;
                }

                // Build quoted column list and find first field for fallback name
                var col_list: std.ArrayList(u8) = .empty;
                defer col_list.deinit(allocator);
                var first_col_name: []const u8 = "";
                var first = true;
                for (parts.items) |p| {
                    // Parse field name and optional sort order: fieldName(sort: Desc)
                    var field_name = p;
                    var sort_order: ?[]const u8 = null;

                    if (std.mem.indexOf(u8, p, "(")) |paren_pos| {
                        field_name = p[0..paren_pos];
                        // Check for sort order
                        if (std.mem.indexOf(u8, p, "Desc")) |_| {
                            sort_order = "DESC";
                        } else if (std.mem.indexOf(u8, p, "Asc")) |_| {
                            sort_order = "ASC";
                        }
                    }

                    var column_name: []const u8 = field_name;
                    if (model.getField(field_name)) |f| {
                        column_name = f.getColumnName();
                    }
                    if (!first) try col_list.appendSlice(allocator, ", ");
                    try col_list.appendSlice(allocator, "\"");
                    try col_list.appendSlice(allocator, column_name);
                    try col_list.appendSlice(allocator, "\"");
                    if (sort_order) |order| {
                        try col_list.appendSlice(allocator, " ");
                        try col_list.appendSlice(allocator, order);
                    }
                    if (first) {
                        first_col_name = column_name;
                        first = false;
                    }
                }

                // Determine index name if provided: look for name: "..."
                var index_name: ?[]const u8 = null;
                if (std.mem.indexOf(u8, raw, "name")) |npos| {
                    const q1 = std.mem.indexOfPos(u8, raw, npos, "\"") orelse 0;
                    const q2 = std.mem.lastIndexOf(u8, raw, "\"") orelse raw.len;
                    if (q1 < q2) {
                        index_name = raw[q1 + 1 .. q2];
                    }
                }

                const idx_name = if (index_name) |inm| inm else try std.fmt.allocPrint(allocator, "{s}_{s}_idx", .{ table_name.value, first_col_name });
                defer if (index_name == null) allocator.free(idx_name);

                try writer.print("-- Create model index\nCREATE INDEX IF NOT EXISTS \"{s}\" ON \"{s}\"({s});\n\n", .{ idx_name, table_name.value, col_list.items });
            }
        }
    }

    // Generate foreign key constraints
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        for (model.fields.items) |field| {
            // Check if this field has a @relation attribute with fields and references
            for (field.attributes.items) |attr| {
                if (attr == .relation) {
                    const rel = attr.relation;

                    // Only generate FK if this side defines the fields (owning side)
                    if (rel.fields != null and rel.references != null and rel.fields.?.len > 0 and rel.references.?.len > 0) {
                        const fields = rel.fields.?;
                        const references = rel.references.?;

                        // Determine the referenced table name from the field type
                        const ref_model_name = field.type.getModelName() orelse continue;

                        // Get the actual table name from the referenced model (respects @@map)
                        const ref_model_lookup = schema.getModel(ref_model_name) orelse continue;
                        const ref_table = try ref_model_lookup.getTableName(allocator);
                        defer if (ref_table.heap_allocated) allocator.free(ref_table.value);

                        // Build field list and reference list using mapped column names
                        var field_list: std.ArrayList(u8) = .empty;
                        defer field_list.deinit(allocator);
                        var ref_list: std.ArrayList(u8) = .empty;
                        defer ref_list.deinit(allocator);

                        // Map field names to actual column names (handle @map)
                        for (fields, 0..) |fld, i| {
                            if (i > 0) try field_list.appendSlice(allocator, ", ");
                            try field_list.append(allocator, '"');

                            // Look up the field in the current model to get its column name
                            if (model.getField(fld.value)) |field_def| {
                                try field_list.appendSlice(allocator, field_def.getColumnName());
                            } else {
                                // Fallback to field name if not found
                                try field_list.appendSlice(allocator, fld.value);
                            }
                            try field_list.append(allocator, '"');
                        }

                        // Get the referenced model to map reference field names to column names
                        const ref_model = schema.getModel(ref_model_name);
                        for (references, 0..) |ref, i| {
                            if (i > 0) try ref_list.appendSlice(allocator, ", ");
                            try ref_list.append(allocator, '"');

                            // Look up the field in the referenced model to get its column name
                            if (ref_model) |rm| {
                                if (rm.getField(ref.value)) |ref_field_def| {
                                    try ref_list.appendSlice(allocator, ref_field_def.getColumnName());
                                } else {
                                    try ref_list.appendSlice(allocator, ref.value);
                                }
                            } else {
                                // Fallback to field name if model not found
                                try ref_list.appendSlice(allocator, ref.value);
                            }
                            try ref_list.append(allocator, '"');
                        }

                        // Map Prisma actions to SQL
                        const on_delete = if (rel.onDelete) |action|
                            mapReferentialAction(action)
                        else
                            "NO ACTION";
                        const on_update = if (rel.onUpdate) |action|
                            mapReferentialAction(action)
                        else
                            "NO ACTION";

                        // Generate constraint name
                        const constraint_name = try std.fmt.allocPrint(allocator, "{s}_{s}_fkey", .{ table_name.value, fields[0].value });
                        defer allocator.free(constraint_name);

                        try writer.print("-- Create foreign key constraint\nALTER TABLE \"{s}\" ADD CONSTRAINT \"{s}\" FOREIGN KEY ({s}) REFERENCES \"{s}\"({s}) ON DELETE {s} ON UPDATE {s};\n\n", .{ table_name.value, constraint_name, field_list.items, ref_table.value, ref_list.items, on_delete, on_update });
                    }
                }
            }
        }
    }

    return sql.toOwnedSlice(allocator);
}
