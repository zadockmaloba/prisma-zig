const std = @import("std");
const pq = @import("libpq_zig");
const types = @import("schema/types.zig");

pub fn generateMigrationSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Migration generated by Prisma Zig\n");
    try writer.writeAll("-- This is a basic migration that creates tables for all models\n\n");

    // Generate CREATE TABLE statements for each model
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        try writer.print("-- CreateTable\nCREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            // Skip relationship fields (they don't map to columns directly)
            if (field.type.isRelation()) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else {
                        const sql_type = field.type.toSqlType();
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    const sql_type = field.type.toSqlType();
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                const sql_type = field.type.toSqlType();
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }
            }

            // Add unique constraint for non-primary-key unique fields
            if (field.isUnique() and !field.isPrimaryKey()) {
                try writer.writeAll(" UNIQUE");
            }

            // Add default values (skip autoincrement as it's handled above)
            if (!field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (field.type == .string) {
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate indexes for unique fields and foreign keys
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        for (model.fields.items) |*field| {
            if (field.isUnique() and !field.isPrimaryKey()) {
                const column_name = field.getColumnName();
                try writer.print("-- CreateIndex\nCREATE UNIQUE INDEX \"{s}_{s}_key\" ON \"{s}\"(\"{s}\");\n\n", .{ table_name.value, column_name, table_name.value, column_name });
            }
        }
    }

    return sql.toOwnedSlice(allocator);
}

pub fn generatePushSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    // This generates SQL to push the schema to the database
    // Similar to generateMigrationSql but without the migration metadata

    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Schema push generated by Prisma Zig\n");
    try writer.writeAll("-- Applying current schema to database\n\n");

    // For a real implementation, we would:
    // 1. Compare current database schema with Prisma schema
    // 2. Generate ALTER TABLE, CREATE TABLE, DROP TABLE statements as needed
    // 3. Handle index creation/deletion
    // 4. Handle foreign key constraints

    // For now, generate basic CREATE TABLE statements
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        try writer.print("CREATE TABLE IF NOT EXISTS \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            if (field.type.isRelation()) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else {
                        const sql_type = field.type.toSqlType();
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    const sql_type = field.type.toSqlType();
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                const sql_type = field.type.toSqlType();
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }

                if (field.isUnique()) {
                    try writer.writeAll(" UNIQUE");
                }

                // Add default values for non-primary-key fields
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (field.type == .string) {
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    return sql.toOwnedSlice(allocator);
}
