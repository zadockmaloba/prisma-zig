const std = @import("std");
const pq = @import("libpq_zig");
const types = @import("schema/types.zig");

pub fn generateMigrationSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Migration generated by Prisma Zig\n");
    try writer.writeAll("-- This is a basic migration that creates tables for all models\n\n");

    // Generate CREATE TABLE statements for each model
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        const db_provider = if (schema.datasource) |ds| ds.provider else "postgresql";

        try writer.print("-- DropTable if exists\nDROP TABLE IF EXISTS \"{s}\" CASCADE;\n\n", .{table_name.value});
        try writer.print("-- CreateTable\nCREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            // Skip relationship fields (they don't map to columns directly)
            if (field.type.isRelation()) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else if (std.mem.eql(u8, default_val, "uuid()")) {
                        // Handle UUID default
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY DEFAULT gen_random_uuid()", .{ column_name, sql_type });
                    } else {
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    var sql_type_buf: [64]u8 = undefined;
                    const sql_type_raw = field.getSqlType(db_provider);
                    const sql_type = blk: {
                        if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                            var i: usize = 0;
                            for (sql_type_raw) |c| {
                                sql_type_buf[i] = std.ascii.toUpper(c);
                                i += 1;
                                if (i >= sql_type_buf.len) break;
                            }
                            break :blk sql_type_buf[0..sql_type_raw.len];
                        }
                        break :blk sql_type_raw;
                    };
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                var sql_type_buf: [64]u8 = undefined;
                const sql_type_raw = field.getSqlType(db_provider);
                const sql_type = blk: {
                    if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                        var i: usize = 0;
                        for (sql_type_raw) |c| {
                            sql_type_buf[i] = std.ascii.toUpper(c);
                            i += 1;
                            if (i >= sql_type_buf.len) break;
                        }
                        break :blk sql_type_buf[0..sql_type_raw.len];
                    }
                    break :blk sql_type_raw;
                };
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }
            }

            // Add unique constraint for non-primary-key unique fields
            if (field.isUnique() and !field.isPrimaryKey()) {
                try writer.writeAll(" UNIQUE");
            }

            // Add default values (skip autoincrement as it's handled above)
            if (!field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()") and !std.mem.eql(u8, default_val, "uuid()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (std.mem.startsWith(u8, default_val, "dbgenerated(")) {
                            // Extract the SQL from dbgenerated("...")
                            const start = std.mem.indexOf(u8, default_val, "\"") orelse 0;
                            const end = std.mem.lastIndexOf(u8, default_val, "\"") orelse default_val.len;
                            const sql_expr = if (start < end) default_val[start + 1 .. end] else "";
                            try writer.print(" DEFAULT {s}", .{sql_expr});
                        } else if (field.type == .string) {
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate indexes for unique fields and foreign keys
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        for (model.fields.items) |*field| {
            if (field.isUnique() and !field.isPrimaryKey()) {
                const column_name = field.getColumnName();
                try writer.print("-- CreateIndex\nCREATE UNIQUE INDEX \"{s}_{s}_key\" ON \"{s}\"({s});\n\n", .{ table_name.value, column_name, table_name.value, column_name });
            }
        }

        // Handle model-level @@index(...) attributes
        for (model.indexes.items) |idx| {
            const raw = idx.value;
            // Extract fields between [ and ]
            if (std.mem.indexOf(u8, raw, "[")) |bs| {
                var be = bs + 1;
                while (be < raw.len and raw[be] != ']') : (be += 1) {}
                if (be >= raw.len) be = raw.len - 1;
                const fields_slice = raw[bs + 1 .. be];

                // Split fields by comma
                var parts: std.ArrayList([]const u8) = .empty;
                defer parts.deinit(allocator);
                var start: usize = 0;
                var i: usize = 0;
                while (i <= fields_slice.len) {
                    if (i == fields_slice.len or fields_slice[i] == ',') {
                        // trim start..i
                        var s = start;
                        var e = i;
                        while (s < e and std.ascii.isWhitespace(fields_slice[s])) s += 1;
                        while (e > s and std.ascii.isWhitespace(fields_slice[e - 1])) e -= 1;
                        if (e > s) {
                            try parts.append(allocator, fields_slice[s..e]);
                        }
                        start = i + 1;
                    }
                    i += 1;
                }

                // Build quoted column list and find first field for fallback name
                var col_list: std.ArrayList(u8) = .empty;
                defer col_list.deinit(allocator);
                var first_col_name: []const u8 = "";
                var first = true;
                for (parts.items) |p| {
                    // p is field name (may include whitespace)
                    const field_name = p;
                    var column_name: []const u8 = field_name;
                    if (model.getField(field_name)) |f| {
                        column_name = f.getColumnName();
                    }
                    if (!first) try col_list.appendSlice(allocator, ", ");
                    try col_list.appendSlice(allocator, "\"");
                    try col_list.appendSlice(allocator, column_name);
                    try col_list.appendSlice(allocator, "\"");
                    if (first) {
                        first_col_name = column_name;
                        first = false;
                    }
                }

                // Determine index name if provided: look for name: "..."
                var index_name: ?[]const u8 = null;
                if (std.mem.indexOf(u8, raw, "name")) |npos| {
                    var q1: usize = npos;
                    while (q1 < raw.len and raw[q1] != '"') : (q1 += 1) {}
                    const q2 = std.mem.lastIndexOf(u8, raw, "\"") orelse raw.len;
                    if (q1 < q2) {
                        index_name = raw[q1 + 1 .. q2];
                    }
                }

                const idx_name = if (index_name) |inm| inm else try std.fmt.allocPrint(allocator, "{s}_{s}_idx", .{ table_name.value, first_col_name });
                defer if (index_name == null) allocator.free(idx_name);

                try writer.print("-- Create model index\nCREATE INDEX \"{s}\" ON \"{s}\"({s});\n\n", .{ idx_name, table_name.value, col_list.items });
            }
        }
    }

    return sql.toOwnedSlice(allocator);
}

pub fn generatePushSql(allocator: std.mem.Allocator, schema: *const types.Schema) ![]u8 {
    // This generates SQL to push the schema to the database
    // Similar to generateMigrationSql but without the migration metadata

    var sql: std.ArrayList(u8) = .empty;
    defer sql.deinit(allocator);

    const writer = sql.writer(allocator);

    try writer.writeAll("-- Schema push generated by Prisma Zig\n");
    try writer.writeAll("-- Applying current schema to database\n\n");

    // For a real implementation, we would:
    // 1. Compare current database schema with Prisma schema
    // 2. Generate ALTER TABLE, CREATE TABLE, DROP TABLE statements as needed
    // 3. Handle index creation/deletion
    // 4. Handle foreign key constraints

    // Drop and recreate tables to handle schema changes
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        try writer.print("DROP TABLE IF EXISTS \"{s}\" CASCADE;\n", .{table_name.value});
    }

    try writer.writeAll("\n");

    // Now create all tables
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        const db_provider = if (schema.datasource) |ds| ds.provider else "postgresql";

        try writer.print("CREATE TABLE \"{s}\" (\n", .{table_name.value});

        var first_field = true;
        for (model.fields.items) |*field| {
            if (field.type.isRelation()) {
                continue;
            }

            if (!first_field) {
                try writer.writeAll(",\n");
            }
            first_field = false;

            const column_name = field.getColumnName();

            // Handle auto-increment primary keys specially
            if (field.isPrimaryKey()) {
                if (field.getDefaultValue()) |default_val| {
                    if (std.mem.eql(u8, default_val, "autoincrement()")) {
                        // Use SERIAL for PostgreSQL auto-increment
                        try writer.print("    \"{s}\" SERIAL PRIMARY KEY", .{column_name});
                    } else if (std.mem.eql(u8, default_val, "uuid()")) {
                        // Handle UUID default
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY DEFAULT gen_random_uuid()", .{ column_name, sql_type });
                    } else if (std.mem.startsWith(u8, default_val, "dbgenerated(")) {
                        // Handle dbgenerated() - extract SQL expression from dbgenerated("...")
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        // Extract the SQL from dbgenerated("...")
                        const start = std.mem.indexOf(u8, default_val, "\"") orelse 0;
                        const end = std.mem.lastIndexOf(u8, default_val, "\"") orelse default_val.len;
                        const sql_expr = if (start < end) default_val[start + 1 .. end] else "";
                        try writer.print("    \"{s}\" {s} PRIMARY KEY DEFAULT {s}", .{ column_name, sql_type, sql_expr });
                    } else {
                        var sql_type_buf: [64]u8 = undefined;
                        const sql_type_raw = field.getSqlType(db_provider);
                        const sql_type = blk: {
                            if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                                var i: usize = 0;
                                for (sql_type_raw) |c| {
                                    sql_type_buf[i] = std.ascii.toUpper(c);
                                    i += 1;
                                    if (i >= sql_type_buf.len) break;
                                }
                                break :blk sql_type_buf[0..sql_type_raw.len];
                            }
                            break :blk sql_type_raw;
                        };
                        try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                    }
                } else {
                    var sql_type_buf: [64]u8 = undefined;
                    const sql_type_raw = field.getSqlType(db_provider);
                    const sql_type = blk: {
                        if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                            var i: usize = 0;
                            for (sql_type_raw) |c| {
                                sql_type_buf[i] = std.ascii.toUpper(c);
                                i += 1;
                                if (i >= sql_type_buf.len) break;
                            }
                            break :blk sql_type_buf[0..sql_type_raw.len];
                        }
                        break :blk sql_type_raw;
                    };
                    try writer.print("    \"{s}\" {s} PRIMARY KEY", .{ column_name, sql_type });
                }
            } else {
                var sql_type_buf: [64]u8 = undefined;
                const sql_type_raw = field.getSqlType(db_provider);
                const sql_type = blk: {
                    if (std.mem.indexOf(u8, sql_type_raw, "(")) |_| {
                        var i: usize = 0;
                        for (sql_type_raw) |c| {
                            sql_type_buf[i] = std.ascii.toUpper(c);
                            i += 1;
                            if (i >= sql_type_buf.len) break;
                        }
                        break :blk sql_type_buf[0..sql_type_raw.len];
                    }
                    break :blk sql_type_raw;
                };
                try writer.print("    \"{s}\" {s}", .{ column_name, sql_type });
                if (!field.optional) {
                    try writer.writeAll(" NOT NULL");
                }

                if (field.isUnique()) {
                    try writer.writeAll(" UNIQUE");
                }

                // Add default values for non-primary-key fields
                if (field.getDefaultValue()) |default_val| {
                    if (!std.mem.eql(u8, default_val, "autoincrement()") and !std.mem.eql(u8, default_val, "uuid()")) {
                        if (std.mem.eql(u8, default_val, "now()")) {
                            try writer.writeAll(" DEFAULT CURRENT_TIMESTAMP");
                        } else if (std.mem.startsWith(u8, default_val, "dbgenerated(")) {
                            // Extract the SQL from dbgenerated("...")
                            const start = std.mem.indexOf(u8, default_val, "\"") orelse 0;
                            const end = std.mem.lastIndexOf(u8, default_val, "\"") orelse default_val.len;
                            const sql_expr = if (start < end) default_val[start + 1 .. end] else "";
                            try writer.print(" DEFAULT {s}", .{sql_expr});
                        } else if (field.type == .string) {
                            try writer.print(" DEFAULT '{s}'", .{default_val});
                        } else if (field.type == .boolean) {
                            const bool_val = if (std.mem.eql(u8, default_val, "true")) "TRUE" else "FALSE";
                            try writer.print(" DEFAULT {s}", .{bool_val});
                        } else {
                            try writer.print(" DEFAULT {s}", .{default_val});
                        }
                    }
                }
            }
        }

        try writer.writeAll("\n);\n\n");
    }

    // Generate indexes for unique fields and model-level @@index
    for (schema.models.items) |*model| {
        const table_name = try model.getTableName(allocator);
        defer if (table_name.heap_allocated) allocator.free(table_name.value);

        // Handle model-level @@index(...) attributes
        for (model.indexes.items) |idx| {
            const raw = idx.value;
            // Extract fields between [ and ]
            if (std.mem.indexOf(u8, raw, "[")) |bs| {
                var be = bs + 1;
                while (be < raw.len and raw[be] != ']') : (be += 1) {}
                if (be >= raw.len) be = raw.len - 1;
                const fields_slice = raw[bs + 1 .. be];

                // Split fields by comma
                var parts: std.ArrayList([]const u8) = .empty;
                defer parts.deinit(allocator);
                var start: usize = 0;
                var i: usize = 0;
                while (i <= fields_slice.len) {
                    if (i == fields_slice.len or fields_slice[i] == ',') {
                        // trim start..i
                        var s = start;
                        var e = i;
                        while (s < e and std.ascii.isWhitespace(fields_slice[s])) s += 1;
                        while (e > s and std.ascii.isWhitespace(fields_slice[e - 1])) e -= 1;
                        if (e > s) {
                            try parts.append(allocator, fields_slice[s..e]);
                        }
                        start = i + 1;
                    }
                    i += 1;
                }

                // Build quoted column list and find first field for fallback name
                var col_list: std.ArrayList(u8) = .empty;
                defer col_list.deinit(allocator);
                var first_col_name: []const u8 = "";
                var first = true;
                for (parts.items) |p| {
                    // p is field name (may include whitespace)
                    const field_name = p;
                    var column_name: []const u8 = field_name;
                    if (model.getField(field_name)) |f| {
                        column_name = f.getColumnName();
                    }
                    if (!first) try col_list.appendSlice(allocator, ", ");
                    //try col_list.appendSlice(allocator, "\"");
                    try col_list.appendSlice(allocator, column_name);
                    //try col_list.appendSlice(allocator, "\"");
                    if (first) {
                        first_col_name = column_name;
                        first = false;
                    }
                }

                // Determine index name if provided: look for name: "..."
                var index_name: ?[]const u8 = null;
                if (std.mem.indexOf(u8, raw, "name")) |npos| {
                    const q1 = std.mem.indexOfPos(u8, raw, npos, "\"") orelse 0;
                    const q2 = std.mem.lastIndexOf(u8, raw, "\"") orelse raw.len;
                    if (q1 < q2) {
                        index_name = raw[q1 + 1 .. q2];
                    }
                }

                const idx_name = if (index_name) |inm| inm else try std.fmt.allocPrint(allocator, "{s}_{s}_idx", .{ table_name.value, first_col_name });
                defer if (index_name == null) allocator.free(idx_name);

                try writer.print("-- Create model index\nCREATE INDEX \"{s}\" ON \"{s}\"({s});\n\n", .{ idx_name, table_name.value, col_list.items });
            }
        }
    }

    return sql.toOwnedSlice(allocator);
}
